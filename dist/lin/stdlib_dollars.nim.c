/* Generated by Nim Compiler v1.4.2 */
/*   (c) 2020 Andreas Rumpf */
/* The generated code is subject to the original license. */
#define NIM_INTBITS 64

/* section: NIM_merge_HEADERS */

#include "nimbase.h"
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef far
#undef powerpc
#undef unix

/* section: NIM_merge_FRAME_DEFINES */
#define nimfr_(x, y)
#define nimln_(x, y)

/* section: NIM_merge_FORWARD_TYPES */
typedef struct NimStrPayload NimStrPayload;
typedef struct NimStringV2 NimStringV2;

/* section: NIM_merge_TYPES */
struct NimStrPayload {
NI cap;
NIM_CHAR data[SEQ_DECL_SIZE];
};
struct NimStringV2 {
NI len;
NimStrPayload* p;
};

/* section: NIM_merge_PROC_HEADERS */
N_LIB_PRIVATE N_NIMCALL(void, eqsink___aBBXmHFBEivKqERloP6zmA)(NimStringV2* dest, NimStringV2 src);
N_NIMCALL(NimStringV2, mnewString)(NI len);
static N_INLINE(void, nimPrepareStrMutationV2)(NimStringV2* s);
N_LIB_PRIVATE N_NIMCALL(void, nimPrepareStrMutationImpl__C0YoABEefTaYbWLv9aVOzZA)(NimStringV2* s);
N_LIB_PRIVATE N_NIMCALL(void, setLengthStrV2)(NimStringV2* s, NI newLen);

/* section: NIM_merge_DATA */
static const struct {
  NI cap; NIM_CHAR data[1+1];
} TM__n49a9aYp5BrbXv9a6OCpJYm0g_2 = { 1 | NIM_STRLIT_FLAG, "0" };
static const NimStringV2 TM__n49a9aYp5BrbXv9a6OCpJYm0g_3 = {1, (NimStrPayload*)&TM__n49a9aYp5BrbXv9a6OCpJYm0g_2};

/* section: NIM_merge_PROCS */
static N_INLINE(void, nimPrepareStrMutationV2)(NimStringV2* s) {
	{
		NIM_BOOL T3_;
		T3_ = (NIM_BOOL)0;
		T3_ = !(((*s).p == ((NimStrPayload*) NIM_NIL)));
		if (!(T3_)) goto LA4_;
		T3_ = ((NI)((*(*s).p).cap & ((NI) IL64(4611686018427387904))) == ((NI) IL64(4611686018427387904)));
		LA4_: ;
		if (!T3_) goto LA5_;
		nimPrepareStrMutationImpl__C0YoABEefTaYbWLv9aVOzZA(s);
	}
	LA5_: ;
}
N_LIB_PRIVATE N_NIMCALL(NimStringV2, dollar___M2d4UEGH9cZOvte6rEhvUTQ)(NU64 x) {
	NimStringV2 result;
	result.len = 0; result.p = NIM_NIL;
	{
		if (!(x == 0ULL)) goto LA3_;
		result = TM__n49a9aYp5BrbXv9a6OCpJYm0g_3;
	}
	goto LA1_;
	LA3_: ;
	{
		NimStringV2 T6_;
		NI i;
		NU64 n;
		NI half;
		T6_.len = 0; T6_.p = NIM_NIL;
		T6_ = mnewString(((NI) 60));
		eqsink___aBBXmHFBEivKqERloP6zmA((&result), T6_);
		i = ((NI) 0);
		n = x;
		{
			while (1) {
				NU64 nn;
				if (!!((n == 0ULL))) goto LA8;
				nn = (NU64)((NU64)(n) / (NU64)(10ULL));
				nimPrepareStrMutationV2((&result));
				result.p->data[i] = ((NIM_CHAR) ((NU64)((NU64)((NU64)((NU64)(n) - (NU64)((NU64)((NU64)(10ULL) * (NU64)(nn))))) + (NU64)(48ULL))));
				i += ((NI) 1);
				n = nn;
			} LA8: ;
		}
		setLengthStrV2((&result), ((NI) (i)));
		half = (NI)(i / ((NI) 2));
		{
			NI t;
			NI colontmp_;
			NI res;
			t = (NI)0;
			colontmp_ = (NI)0;
			colontmp_ = (NI)(half - ((NI) 1));
			res = ((NI) 0);
			{
				while (1) {
					NIM_CHAR T12_;
					if (!(res <= colontmp_)) goto LA11;
					t = res;
					nimPrepareStrMutationV2((&result));
					nimPrepareStrMutationV2((&result));
					T12_ = (NIM_CHAR)0;
					T12_ = result.p->data[t];
					result.p->data[t] = result.p->data[(NI)((NI)(i - t) - ((NI) 1))];
					result.p->data[(NI)((NI)(i - t) - ((NI) 1))] = T12_;
					res += ((NI) 1);
				} LA11: ;
			}
		}
	}
	LA1_: ;
	return result;
}
